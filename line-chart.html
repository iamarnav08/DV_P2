<!DOCTYPE html>
<html>

<head>
    <title>Analytics Dashboard</title>
    <style>
        * {
            zoom: 97%;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }

        body {
            background: #f8fafc;
            margin: 0;
        }

        .dashboard-header {
            background: white;
            padding: 2rem;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .dashboard-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1e293b;
        }

        .file-input-wrapper {
            position: relative;
        }

        .file-input {
            opacity: 0;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-button {
            padding: 0.75rem 1.5rem;
            background: #3b82f6;
            color: white;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .file-input-button:hover {
            background: #2563eb;
        }

        .stats-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: #f8fafc;
            padding: 1.5rem;
            border-radius: 12px;
            transition: transform 0.2s;
            border: 1px solid #e2e8f0;
        }

        .stat-card:hover {
            transform: translateY(-2px);
        }

        .stat-card h3 {
            color: #64748b;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .stat-card span {
            color: #1e293b;
            font-size: 1.75rem;
            font-weight: 600;
        }

        .filters-section {
            height: 100%;
            overflow-y: auto;
            padding: 1rem;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }


        .filter-title {
            color: #1e293b;
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .round-toggle,
        .player-toggle {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .round-toggle label,
        .player-toggle label {
            padding: 0.5rem 0.75rem;
            font-size: 0.8rem;
            background: #f1f5f9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #e2e8f0;
        }

        .round-toggle label:hover,
        .player-toggle label:hover {
            background: #e2e8f0;
            transform: translateY(-1px);
        }

        .chart-section {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .chart-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .zoom-controls {
            display: flex;
            gap: 0.75rem;
        }

        .zoom-button {
            padding: 0.5rem 1rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            font-size: 0.8rem;
        }

        .zoom-button:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .zoom-button:disabled {
            background: #94a3b8;
            cursor: not-allowed;
            transform: none;
        }

        #chart {
            flex: 1;
            min-height: 0;
            width: 100%;
            height: 500px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 1rem;
            margin-top: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .legend-item:hover {
            background: #f1f5f9;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-item span {
            font-size: 0.875rem;
            color: #475569;
        }

        .zoom-history {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .zoom-level {
            padding: 0.5rem 1rem;
            background: #f1f5f9;
            border-radius: 6px;
            font-size: 0.875rem;
            color: #475569;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #e2e8f0;
        }

        .zoom-level:hover {
            background: #e2e8f0;
            transform: translateY(-1px);
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }

            .filters-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .stats-cards {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 1rem;
            }

            .stat-card {
                padding: 1rem;
            }

            .chart-section {
                padding: 1rem;
            }
        }

        .line {
            fill: none !important;
            /* Force no fill */
            stroke-width: 2;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .solve-line {
            fill: none !important;
            /* Force no fill */
            stroke-width: 2;
            stroke-opacity: 0.7;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        /* Update point styles */
        .point {
            fill-opacity: 1;
            stroke: white;
            stroke-width: 1.5;
        }

        .solve-point {
            fill-opacity: 1;
            stroke: white;
            stroke-width: 1.5;
        }

        /* Update these styles in your style section */
        .filters-section {
            background: white;
            padding: 1.5rem;
            border-radius: 16px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            margin-bottom: 2rem;
        }

        .filters-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .filter-group {
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            padding-left: 1.5rem;
        }

        .filter-title {
            color: #1e293b;
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .filter-content {
            overflow-x: auto;
            padding-bottom: 0.5rem;
        }

        /* Update the toggle containers to horizontal layout */
        .round-toggle,
        .player-toggle {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 0.75rem;
            padding: 0.5rem 0;
        }

        /* Update the label styles for horizontal layout */
        .round-toggle label,
        .player-toggle label {
            display: inline-flex;
            align-items: center;
            padding: 0.5rem 1rem;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #e2e8f0;
            gap: 0.5rem;
            white-space: nowrap;
        }

        .round-toggle label:hover,
        .player-toggle label:hover {
            background: #f1f5f9;
            transform: translateY(-1px);
        }

        /* Update scrollbar styles for horizontal scroll */
        .filter-content::-webkit-scrollbar {
            height: 6px;
            width: 6px;
        }

        .filter-content::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }

        .filter-content::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        /* Optimize checkbox and radio styling */
        .player-toggle label input[type="checkbox"],
        .round-toggle label input[type="radio"] {
            width: 16px;
            height: 16px;
            margin: 0;
            cursor: pointer;
        }

        .player-toggle label .color-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .player-toggle label span {
            font-size: 0.875rem;
            color: #475569;
        }

        /* Active states */
        .round-toggle label.active,
        .player-toggle label.active {
            background: #f1f5f9;
            border-color: #94a3b8;
        }

        /* Add this to your JavaScript updatePlayerToggles function */

        /* Add new layout styles */
        .dashboard-container {
            display: grid;
            grid-template-rows: auto 1fr;
            gap: 1rem;
            /* height: calc(100vh - 2rem); */
            height: 8%;
        }

        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 1rem;
            height: calc(100vh - 150px);
        }

        /* Update filter styles */
        .filters-section {
            background: white;
            padding: 1.5rem;
            border-radius: 16px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            height: 100%;
        }

        .filter-group {}

        .filter-title {
            color: #1e293b;
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
        }

        .round-toggle,
        .player-toggle {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .round-toggle label,
        .player-toggle label {
            position: relative;
            padding: 0.625rem 1rem;
            background: #f8fafc;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.875rem;
            color: #64748b;
            border: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Hide default inputs */
        .round-toggle input,
        .player-toggle input {
            display: none;
        }

        /* Active states */
        .round-toggle label.active {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.1);
        }

        .player-toggle label.active {
            background: #f8fafc;
            border-color: #3b82f6;
            color: #1e293b;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* Color indicators for player toggles */
        .color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transition: transform 0.2s ease;
        }

        .player-toggle label.active .color-indicator {
            transform: scale(1.2);
        }

        /* Hover effects */
        .round-toggle label:hover:not(.active) {
            background: #f1f5f9;
            color: #334155;
        }

        .player-toggle label:hover:not(.active) {
            background: #f1f5f9;
        }

        /* Add subtle animation for selection */
        @keyframes selectPop {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }

            100% {
                transform: scale(1);
            }
        }

        .round-toggle label.active,
        .player-toggle label.active {
            animation: selectPop 0.2s ease;
        }

        /* Scrollbar styling */
        .filter-content {
            max-height: calc(100vh - 400px);
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .filter-content::-webkit-scrollbar {
            width: 4px;
        }

        .filter-content::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 2px;
        }

        .filter-content::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 2px;
        }

        /* Add filter section header */
        .filters-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e2e8f0;
        }

        .filters-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #0f172a;
            margin-bottom: 0.5rem;
        }

        .filters-subtitle {
            font-size: 0.875rem;
            color: #64748b;
        }

        /* Add these styles to your existing style section */
        .grid line {
            stroke: #999999;
            stroke-opacity: 0.5;
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }

        /* Add these tooltip styles in your style section */
        .tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            pointer-events: none;
            font-size: 0.875rem;
            z-index: 1000;
            border: 1px solid #e2e8f0;
            max-width: 200px;
        }

        .tooltip-title {
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 0.25rem;
        }

        .tooltip-content {
            color: #64748b;
            line-height: 1.4;
        }

        /* Update point hover styles */
        .point,
        .solve-point {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .point:hover,
        .solve-point:hover {
            stroke-width: 2px;
            stroke: white;
        }

        /* Update these styles in your CSS section */
        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        .stat-card {
            background: #f8fafc;
            padding: 1rem;
            border-radius: 8px;
            transition: transform 0.2s;
            border: 1px solid #e2e8f0;
            height: auto;
        }

        .stat-card h3 {
            font-size: 0.75rem;
            margin-bottom: 0.25rem;
        }

        .stat-card span {
            font-size: 1.25rem;
        }

        /* Add styles for the new top filters section */
        .top-filters {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .filter-section-left {
            flex: 0 0 300px;
        }

        .filter-section-right {
            flex: 1;
            overflow-x: auto;
        }

        /* Add to your existing styles */
        .solve-label {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            pointer-events: none;
            text-shadow:
                1px 1px 0 white,
                -1px 1px 0 white,
                1px -1px 0 white,
                -1px -1px 0 white;
        }

        .solve-point-group:hover .solve-label {
            font-weight: bold;
        }

        /* Add to your existing styles */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-left: 10px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #3b82f6;
        }

        input:checked+.slider:before {
            transform: translateX(26px);
        }

        .rounds-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .rounds-header-text {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rounds-header-label {
            font-size: 0.75rem;
            color: #64748b;
        }

        /* Add to your existing styles */
        .solve-value-label {
            font-size: 11px;
            font-weight: 500;
            pointer-events: none;
            text-shadow:
                1px 1px 2px white,
                -1px 1px 2px white,
                1px -1px 2px white,
                -1px -1px 2px white;
        }

        .solve-type-label {
            pointer-events: none;
            text-shadow:
                1px 1px 2px white,
                -1px 1px 2px white,
                1px -1px 2px white,
                -1px -1px 2px white;
        }

        .competitor-label {
            pointer-events: none;
            text-shadow:
                1px 1px 2px white,
                -1px 1px 2px white,
                1px -1px 2px white,
                -1px -1px 2px white;
        }

        .solve-point-group:hover .solve-value-label,
        .solve-point-group:hover .solve-type-label {
            font-weight: bold;
        }

        /* Add these styles to your existing CSS */
        .solve-pattern-card {
            margin-top: 1rem;
        }

        .solve-pattern-legend {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .solve-labels {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0 10px;
        }

        .solve-labels span {
            font-size: 0.75rem;
            color: #64748b;
        }

        /* Add to your existing styles */
        .axis-label {
            font-weight: 500;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }

        /* Add these styles to your existing CSS */
        .solve-pattern-card {
            margin-top: 1rem;
            transition: all 0.3s ease;
        }

        .solve-pattern-card.highlighted {
            background: white;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
            transform: translateY(-2px);
            border: 2px solid #3b82f6;
        }

        .solve-pattern-card.highlighted h3 {
            color: #3b82f6;
            font-weight: 600;
        }

        .solve-pattern-legend svg {
            transition: all 0.3s ease;
        }

        .solve-pattern-card.highlighted .solve-pattern-legend svg {
            filter: drop-shadow(0 2px 4px rgba(59, 130, 246, 0.2));
        }

        .solve-pattern-card.highlighted .solve-labels span {
            color: #3b82f6;
            font-weight: 500;
        }

        .competition-label {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            pointer-events: none;
            text-shadow:
                1px 1px 2px white,
                -1px 1px 2px white,
                1px -1px 2px white,
                -1px -1px 2px white;
        }

        .custom-x-labels text {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            font-size: 11px;
            fill: #64748b;
        }
    </style>
</head>

<body>
    <div class="dashboard-container">
        <!-- Stats Section at top -->
        <div class="stats-section">
            <!-- Replace the existing rounds section with this -->
            <div class="filter-group">
                <div class="rounds-header" style="flex-direction: row;justify-content: left;">
                    <h3 class="filter-title">Round Selection</h3>
                    <div class="rounds-header-text" style="margin-left: 20px;">
                        <span class="rounds-header-label">Show All Rounds</span>
                        <label class="switch">
                            <input type="checkbox" id="showAllRoundsToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                <div class="filter-content">
                    <div id="round-toggles" class="round-toggle"></div>
                    <h3 class="filter-title">Competitors</h3>
                    <div class="filter-content">
                        <div id="player-toggles" class="player-toggle"></div>
                    </div>
                </div>

            </div>
        </div>


    </div>

    <!-- Main Content Area -->
    <div class="main-content">
        <!-- Filters on left -->
        <div class="filter-group">

            <div class="stat-card">
                <h3>Total Competitors</h3>
                <span id="totalCompetitors">0</span>
            </div>
            <div class="stat-card">
                <h3>Best Time</h3>
                <span id="bestAverage">-</span>
            </div>
            <div class="stat-card">
                <h3>Active Round</h3>
                <span id="activeRound">-</span>
            </div>
            <div class="stat-card">
                <h3>Selected Players</h3>
                <span id="selectedCount">0</span>
            </div>
            <div class="stat-card">
                <h3>View Mode</h3>
                <span id="viewType">Overview</span>
            </div>
            <!-- Add this HTML after the existing stat cards in the filter-group div -->
            <div class="stat-card solve-pattern-card">
                <h3>Solve Pattern</h3>
                <div class="solve-pattern-legend">
                    <svg width="200" height="100"></svg>
                    <div class="solve-labels">
                        <span>S1</span>
                        <span>S2</span>
                        <span>S3</span>
                        <span>S4</span>
                        <span>S5</span>
                    </div>
                </div>
            </div>
        </div>
        <!-- Chart on right -->
        <div class="chart-section">
            <div class="chart-controls">
                <div class="zoom-controls">
                    <button class="zoom-button" id="resetZoom">Reset View</button>
                </div>
                <div id="zoomHistory" class="zoom-history"></div>
            </div>
            <div id="chart"></div>
            <div id="legend" class="legend"></div>
        </div>
    </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
        // State management
        let state = {
            zoomStack: [],
            currentZoomLevel: 0,
            isDetailedView: false,
            detailedViewData: null,
            competitors: {},
            activeCompetitors: [],
            activeRounds: [],
            allRounds: [],
            currentChartData: [],
            chartInitialized: false,
            isLoading: false,
            showingAllRounds: false  // Add this new property
        };

        // Add this function after the updateChart function
        function updateLegend() {
            const legendContainer = d3.select("#legend");
            legendContainer.html(""); // Clear existing legend

            state.activeCompetitors.forEach(name => {
                const legendItem = legendContainer.append("div")
                    .attr("class", "legend-item");

                legendItem.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorScale(name));

                legendItem.append("span")
                    .text(name);
            });
        }

        // Chart setup
        const margin = {
            top: 20,
            right: 80,
            bottom: 50,  // Increased to accommodate x-axis label
            left: 50     // Increased to accommodate y-axis label
        };
        const width = 1200 - margin.left - margin.right;
        const height = 540 - margin.top - margin.bottom;

        const svg = d3.select("#chart")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0)
            .style("pointer-events", "none");

        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
        const x = d3.scaleLinear().range([0, width]);
        const y = d3.scaleLinear().range([height, 0]);

        // Create clip path
        svg.append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", width)
            .attr("height", height);

        const xAxis = svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${height})`);

        const yAxis = svg.append("g")
            .attr("class", "y-axis");

        const chartContent = svg.append("g")
            .attr("clip-path", "url(#clip)");

        const brush = d3.brushX()
            .extent([[0, 0], [width, height]])
            .on("end", brushended);

        chartContent.append("g")
            .attr("class", "brush")
            .call(brush);

        // Add grid lines
        const xGrid = svg.append("g")
            .attr("class", "grid")
            .attr("transform", `translate(0,${height})`);

        const yGrid = svg.append("g")
            .attr("class", "grid");

        // Add X-axis label with arrow
        svg.append("text")
            .attr("class", "axis-label")
            .attr("x", width / 2)
            .attr("y", height + 45)  // Position below x-axis
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .style("fill", "#475569")
            .text("Competitions ➜");

        // Add Y-axis label with arrow
        svg.append("text")
            .attr("class", "axis-label")
            .attr("transform", "rotate(-90)")
            .attr("x", -height / 2)
            .attr("y", -40)  // Position left of y-axis
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .style("fill", "#475569")
            .text("Time ➜");

        // Loading indicator
        function showLoading() {
            state.isLoading = true;
            d3.select("#chart")
                .append("div")
                .attr("class", "loading")
                .text("Loading...");
        }

        function hideLoading() {
            state.isLoading = false;
            d3.select("#chart").selectAll(".loading").remove();
        }

        // Error handling
        function displayError(message) {
            const errorDiv = d3.select("#chart")
                .append("div")
                .attr("class", "error-message");

            errorDiv.text(message)
                .style("opacity", 0)
                .transition()
                .duration(300)
                .style("opacity", 1);

            setTimeout(() => {
                errorDiv.transition()
                    .duration(300)
                    .style("opacity", 0)
                    .remove();
            }, 3000);
        }

        // Clean up function
        function cleanupChart() {
            chartContent.selectAll(".line, .point, .solve-point, .solve-line, .solve-label, .competition-label")
                .transition()
                .duration(375)
                .style("opacity", 0)
                .remove();

            tooltip.style("opacity", 0);
        }

        // Safe parsing function
        function safeParseFloat(value) {
            const parsed = parseFloat(value);
            return isNaN(parsed) ? null : parsed;
        }

        // Update zoom history
        function updateZoomHistory() {
            const container = d3.select("#zoomHistory");
            container.html("");

            state.zoomStack.forEach((zoom, index) => {
                container.append("div")
                    .attr("class", "zoom-level")
                    .text(`Zoom ${index + 1}`)
                    .on("click", () => {
                        while (state.currentZoomLevel > index + 1) {
                            zoomOut();
                        }
                    });
            });
        }

        // Brush ended function
        function brushended(event) {
            if (!event.selection) return;

            const [x0, x1] = event.selection.map(x.invert);

            // Get points that are completely within selection with a smaller buffer
            const buffer = 0.05;
            const selectedPoints = state.currentChartData.filter(d => {
                const isWithinBounds = d.index >= (x0 + buffer) && d.index <= (x1 - buffer);
                return isWithinBounds && state.activeCompetitors.includes(d.name);
            });

            // Group by exact index to ensure we only get complete competitions
            const pointsByIndex = d3.group(selectedPoints, d => Math.round(d.index));

            // Find indices that have all competitors
            const validIndices = Array.from(pointsByIndex.entries())
                .filter(([_, points]) => points.length === state.activeCompetitors.length)
                .map(([index]) => Number(index));

            if (validIndices.length === 0) {
                displayError("Please select complete competitions");
                chartContent.select(".brush").call(brush.move, null);
                return;
            }

            // Get only the data points for complete competitions
            const finalSelection = selectedPoints.filter(d =>
                validIndices.includes(Math.round(d.index))
            );

            // Save state and update
            state.zoomStack.push({
                isDetailedView: state.isDetailedView,
                detailedViewData: state.detailedViewData,
                xDomain: x.domain(),
                yDomain: y.domain(),
                selectedData: finalSelection,
                currentChartData: state.currentChartData.slice()
            });

            state.currentZoomLevel++;
            state.isDetailedView = true;
            state.detailedViewData = finalSelection;

            // Call detailed view with the properly selected points
            updateDetailedView(finalSelection);
            updateZoomHistory();
            updateStats();

            chartContent.select(".brush").call(brush.move, null);
        }

        function zoomOut() {
            if (state.zoomStack.length > 0) {
                const previousState = state.zoomStack.pop();
                state.currentZoomLevel--;

                // Restore the previous state
                state.isDetailedView = previousState.isDetailedView;
                state.detailedViewData = previousState.detailedViewData;
                state.currentChartData = previousState.currentChartData;

                if (previousState.isDetailedView) {
                    // If previous state was detailed view, restore it
                    x.domain(previousState.xDomain);
                    y.domain(previousState.yDomain);
                    updateDetailedView(previousState.selectedData);
                } else {
                    // If previous state was overview, restore normal chart
                    updateChart();
                }

                updateZoomHistory();
                updateStats();
            } else {
                // If no more zoom states, reset to initial view
                state.isDetailedView = false;
                state.detailedViewData = null;
                updateChart();
            }
        }

        // Update detailed view
        function updateDetailedView(selectedData) {
            try {
                // Group data by competition to ensure we show all solves from same competition
                const competitionGroups = d3.group(selectedData, d => d.competition);

                // Create expanded data including all solves for selected competitions
                const expandedData = Array.from(competitionGroups).flatMap(([competition, points]) => {
                    return points.flatMap(d => [
                        { index: Math.round(d.index) - 0.4, value: d.solve1, name: d.name, type: "Solve 1", average: d.average, competition: d.competition },
                        { index: Math.round(d.index) - 0.2, value: d.solve2, name: d.name, type: "Solve 2", average: d.average, competition: d.competition },
                        { index: Math.round(d.index), value: d.solve3, name: d.name, type: "Solve 3", average: d.average, competition: d.competition },
                        { index: Math.round(d.index) + 0.2, value: d.solve4, name: d.name, type: "Solve 4", average: d.average, competition: d.competition },
                        { index: Math.round(d.index) + 0.4, value: d.solve5, name: d.name, type: "Solve 5", average: d.average, competition: d.competition }
                    ]);
                });

                // Get the unique indices for the x-axis domain
                const selectedIndices = [...new Set(selectedData.map(d => Math.round(d.index)))];

                // Update scales with padding
                x.domain([
                    d3.min(selectedIndices) - 0.7,
                    d3.max(selectedIndices) + 0.7
                ]);

                // Update y domain using only valid solve values
                const validSolves = expandedData.filter(d => d.value != null && !isNaN(d.value));
                const yMin = d3.min(validSolves, d => d.value);
                const yMax = d3.max(validSolves, d => d.value);
                const yPadding = (yMax - yMin) * 0.1;

                y.domain([
                    yMin - yPadding,
                    yMax + yPadding
                ]);

                // Rest of the visualization code remains the same...
                const t = d3.transition().duration(750);

                // Update axes and grid...
                xAxis.transition(t).call(d3.axisBottom(x));
                yAxis.transition(t).call(d3.axisLeft(y));

                // Clear previous elements
                cleanupChart();

                // Add points and labels for valid solves
                const solvePointGroup = chartContent.selectAll(".solve-point-group")
                    .data(validSolves)
                    .enter()
                    .append("g")
                    .attr("class", "solve-point-group");

                // Add the connecting lines first (so they appear behind points)
                // Add points
                solvePointGroup.append("circle")
                    .attr("class", "solve-point")
                    .attr("r", 4)
                    .attr("cx", d => x(d.index))
                    .attr("cy", d => y(d.value))
                    .style("fill", d => colorScale(d.name));

                // Add value labels above points
                // solvePointGroup.append("text")
                //     .attr("class", "solve-value-label")
                //     .attr("x", d => x(d.index))
                //     .attr("y", d => y(d.value) - 10)
                //     .attr("text-anchor", "middle")
                //     .text(d => d.value.toFixed(2));

                // Add solve type labels above values
                // solvePointGroup.append("text")
                //     .attr("class", "solve-type-label")
                //     .attr("x", d => x(d.index))
                //     .attr("y", d => y(d.value) - 25)
                //     .attr("text-anchor", "middle")
                //     .style("font-size", "10px")
                //     .style("fill", "#475569")
                //     .style("font-weight", "500")
                //     .text(d => d.type);

                // Add competitor name above solve type for first solve only
                // solvePointGroup.filter(d => d.type === "Solve 1")
                //     .append("text")
                //     .attr("class", "competitor-label")
                //     .attr("x", d => x(d.index))
                //     .attr("y", d => y(d.value) - 40)
                //     .attr("text-anchor", "middle")
                //     .style("font-size", "12px")
                //     .style("fill", d => colorScale(d.name))
                //     .style("font-weight", "bold")
                //     .text(d => d.name);

                // Update interactivity for the groups
                solvePointGroup
                    .on("mouseover", function (event, d) {
                        const group = d3.select(this);
                        const point = group.select("circle");
                        const label = group.select("text");

                        point.transition()
                            .duration(200)
                            .attr("r", 6)
                            .style("stroke-width", "2px");

                        label.transition()
                            .duration(200)
                            .style("font-weight", "bold");

                        tooltip.transition()
                            .duration(200)
                            .style("opacity", 1);

                        tooltip.html(`
                            <div class="tooltip-title">${d.name}</div>
                            <div class="tooltip-content">
                                Competition: ${d.competition}<br>
                                ${d.type}: ${d.value.toFixed(2)}s<br>
                                Average: ${d.average.toFixed(2)}s
                            </div>
                        `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function () {
                        const group = d3.select(this);
                        const point = group.select("circle");
                        const label = group.select("text");

                        point.transition()
                            .duration(200)
                            .attr("r", 4)
                            .style("stroke-width", "1.5px");

                        label.transition()
                            .duration(200)
                            .style("font-weight", "normal");

                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                // Add connecting lines for each player's solves within same competition
                state.activeCompetitors.forEach(name => {
                    competitionGroups.forEach(points => {
                        const playerSolves = points
                            .filter(d => d.name === name)
                            .flatMap(d => [
                                { index: Math.round(d.index) - 0.4, value: d.solve1 },
                                { index: Math.round(d.index) - 0.2, value: d.solve2 },
                                { index: Math.round(d.index), value: d.solve3 },
                                { index: Math.round(d.index) + 0.2, value: d.solve4 },
                                { index: Math.round(d.index) + 0.4, value: d.solve5 }
                            ])
                            .filter(d => d.value != null && !isNaN(d.value));

                        if (playerSolves.length > 1) {
                            chartContent.append("path")
                                .datum(playerSolves)
                                .attr("class", "solve-line")
                                .attr("stroke", colorScale(name))
                                .attr("d", d3.line()
                                    .x(d => x(d.index))
                                    .y(d => y(d.value)))
                                .style("opacity", 0)
                                .transition(t)
                                .style("opacity", 0.7);
                        }
                    });
                });

                // Add interactivity for solve points
                chartContent.selectAll(".solve-point")
                    .on("mouseover", function (event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("r", 6)
                            .style("stroke-width", "2px");

                        tooltip.transition()
                            .duration(200)
                            .style("opacity", 1);

                        // Updated tooltip content with all relevant information
                        tooltip.html(`
                            <div class="tooltip-title">${d.name}</div>
                            <div class="tooltip-content">
                                Competition: ${d.competition}<br>
                                ${d.type}: ${d.value.toFixed(2)}s<br>
                                Average: ${d.average.toFixed(2)}s
                            </div>
                        `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function () {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr("r", 4)
                            .style("stroke-width", "1.5px");

                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                // Add labels for solve types only once at the top
                const firstIndex = d3.min(validSolves, d => Math.floor(d.index));

                // Create solve type labels at the top of the chart
                const solveTypes = ["Solve 1", "Solve 2", "Solve 3", "Solve 4", "Solve 5"];

                // Remove any existing solve legend
                chartContent.selectAll(".solve-legend").remove();

                // Create new solve legend
                const solveLegend = chartContent.append("g")
                    .attr("class", "solve-legend")
                    .attr("transform", `translate(${width - 100}, 20)`); // Adjusted position

                // Add background for better readability
                solveLegend.append("rect")
                    .attr("width", 80)
                    .attr("height", 110)
                    .attr("fill", "white")
                    .attr("opacity", 0.8)
                    .attr("rx", 4);

                // Add solve type labels
                solveTypes.forEach((type, i) => {
                    solveLegend.append("text")
                        .attr("x", 10)
                        .attr("y", 20 + i * 20)
                        .attr("font-size", "12px")
                        .attr("fill", "#1e293b")
                        .attr("font-weight", "500")
                        .text(type);
                });

                // Update x-axis ticks and labels to show competition numbers
                const uniqueIndices = [...new Set(selectedData.map(d => Math.round(d.index)))];
                xAxis.transition(t)
                    .call(d3.axisBottom(x)
                        .tickValues(uniqueIndices)
                        .tickFormat("")) // Remove the original x-axis labels
                    .selectAll("text")
                    .style("text-anchor", "middle");

                // Add custom competition labels
                const customXLabels = svg.append("g")
                    .attr("class", "custom-x-labels")
                    .attr("transform", `translate(0, ${height + 20})`); // Position below x-axis

                uniqueIndices.forEach(index => {
                    customXLabels.append("text")
                        .attr("x", x(index))
                        .attr("y", 0)
                        .attr("text-anchor", "middle")
                        .style("font-size", "12px")
                        .style("fill", "#1e293b")
                        .text(`Competition ${Math.round(index)}`);
                });

                // Add competition labels at the top
                const competitions = [...new Set(selectedData.map(d => d.competition))];
                competitions.forEach(comp => {
                    const compData = selectedData.filter(d => d.competition === comp);
                    const index = compData[0].index;
                    const yPos = y(d3.min(validSolves.filter(d => d.competition === comp), d => d.value)) - 50;

                    chartContent.append("text")
                        .attr("class", "competition-label")
                        .attr("x", x(index))
                        .attr("y", yPos)
                        .attr("text-anchor", "middle")
                        .style("font-size", "12px")
                        .style("fill", "#475569")
                        .style("font-weight", "500")
                        .text(`Competition ${Math.round(index)}`);
                });

                // // Update the solve type labels position to avoid overlap
                // const solveLegend = chartContent.append("g")
                //     .attr("class", "solve-legend")
                //     .attr("transform", `translate(${width - 100}, 60)`); // Increased y-position

                // Remove the previous solve labels and competition labels
                chartContent.selectAll(".solve-label").remove();
                chartContent.selectAll(".competition-label").remove();

                updateSolvePatternLegend(true);

            } catch (error) {
                console.error("Error in detailed view:", error);
                displayError("Error displaying detailed view");
            }
        }

        // Update chart function
        // Update the updateChart function to handle both normal and detailed views

        function updateChart() {
            try {
                cleanupChart();

                if (!state.activeCompetitors.length || !state.activeRounds.length) {
                    displayError("No data selected");
                    return;
                }

                // Special handling for single player view
                const isSinglePlayerView = state.activeCompetitors.length === 1;
                const roundColorScale = getRoundColorScale(state.activeRounds);

                // Update current chart data regardless of view state
                state.currentChartData = [];
                state.activeCompetitors.forEach(name => {
                    if (!state.competitors[name]) return;

                    state.activeRounds.forEach(round => {
                        if (!state.competitors[name][round]) return;

                        state.competitors[name][round].forEach((d, index) => {
                            if (d.average === null) return;

                            state.currentChartData.push({
                                name,
                                index: index + 1,
                                average: d.average,
                                round: d.round,
                                competition: d.competition,
                                solve1: d.solve1,
                                solve2: d.solve2,
                                solve3: d.solve3,
                                solve4: d.solve4,
                                solve5: d.solve5
                            });
                        });
                    });
                });

                if (!state.currentChartData.length) {
                    displayError("No valid data to display");
                    return;
                }

                // If in detailed view, update with filtered data
                if (state.isDetailedView && state.detailedViewData) {
                    const currentSelection = state.detailedViewData[0].index;
                    const filteredData = state.currentChartData.filter(d =>
                        Math.abs(d.index - currentSelection) <= 0.5 &&
                        state.activeCompetitors.includes(d.name)
                    );
                    if (filteredData.length > 0) {
                        updateDetailedView(filteredData);
                    } else {
                        // If no data left in detailed view, reset to overview
                        state.isDetailedView = false;
                        state.detailedViewData = null;
                        state.zoomStack = [];
                        updateZoomHistory();
                    }
                    return;
                }

                // Normal view updates
                const t = d3.transition().duration(750);

                const maxIndex = Math.max(...state.currentChartData.map(d => d.index));
                x.domain([1, maxIndex]);
                y.domain([
                    d3.min(state.currentChartData, d => d.average) * 0.95,
                    d3.max(state.currentChartData, d => d.average) * 1.05
                ]);

                xAxis.transition(t).call(d3.axisBottom(x).ticks(Math.min(20, maxIndex)));
                yAxis.transition(t).call(d3.axisLeft(y));

                // Add grid lines
                xGrid.transition(t)
                    .call(d3.axisBottom(x)
                        .ticks(Math.min(20, maxIndex))
                        .tickSize(-height)
                        .tickFormat("")
                    );

                yGrid.transition(t)
                    .call(d3.axisLeft(y)
                        .tickSize(-width)
                        .tickFormat("")
                    );

                const line = d3.line()
                    .x(d => x(d.index))
                    .y(d => y(d.average))
                    .defined(d => !isNaN(d.average))
                    .curve(d3.curveLinear)

                if (isSinglePlayerView) {
                    // Create separate lines for each round
                    state.activeRounds.forEach(round => {
                        const roundData = state.currentChartData.filter(d => d.round === round);

                        chartContent.append("path")
                            .datum(roundData)
                            .attr("class", "line")
                            .style("stroke", roundColorScale(round))
                            .style("opacity", 0)
                            .transition(t)
                            .style("opacity", 1)
                            .attr("d", line);

                        // Update points for this round
                        const points = chartContent.selectAll(`.point-${round}`)
                            .data(roundData);

                        points.enter()
                            .append("circle")
                            .attr("class", `point point-${round}`)
                            .merge(points)
                            .attr("cx", d => x(d.index))
                            .attr("cy", d => y(d.average))
                            .attr("r", 4)
                            .style("fill", roundColorScale(round));
                    });
                } else {
                    // Original multiple player visualization code
                    const lines = chartContent.selectAll(".line")
                        .data(state.activeCompetitors);

                    lines.exit().remove();

                    lines.enter()
                        .append("path")
                        .attr("class", "line")
                        .merge(lines)
                        .style("stroke", d => colorScale(d))
                        .style("opacity", 0)
                        .transition(t)
                        .style("opacity", 1)
                        .attr("d", name => {
                            const playerData = state.currentChartData.filter(d => d.name === name);
                            return line(playerData);
                        });

                    lines.exit()
                        .transition()
                        .duration(375)
                        .style("opacity", 0)
                        .remove();

                    // Update points with transition
                    const points = chartContent.selectAll(".point")
                        .data(state.currentChartData.filter(d => !isNaN(d.average)));

                    const pointsEnter = points.enter()
                        .append("circle")
                        .attr("class", "point");

                    points.merge(pointsEnter)
                        .attr("cx", d => x(d.index))
                        .attr("cy", d => y(d.average))
                        .attr("r", 4)
                        .style("fill", d => colorScale(d.name))
                        .style("opacity", 0)
                        .transition(t)
                        .style("opacity", 1);

                    points.exit()
                        .transition()
                        .duration(375)
                        .style("opacity", 0)
                        .remove();

                    // Maintain interactivity
                    chartContent.selectAll(".point")
                        .on("mouseover", function (event, d) {
                            d3.select(this)
                                .transition()
                                .duration(200)
                                .attr("r", 6)
                                .style("stroke-width", "2px");

                            tooltip.transition()
                                .duration(200)
                                .style("opacity", 1);

                            tooltip.html(`
                                <div class="tooltip-title">${d.name}</div>
                                <div class="tooltip-content">
                                    Competition: ${d.competition}<br>
                                    Round: ${d.round}<br>
                                    Average: ${d.average.toFixed(2)}s<br>
                                    ${d.solve1 ? `Solve 1: ${d.solve1.toFixed(2)}s<br>` : ''}
                                    ${d.solve2 ? `Solve 2: ${d.solve2.toFixed(2)}s<br>` : ''}
                                    ${d.solve3 ? `Solve 3: ${d.solve3.toFixed(2)}s<br>` : ''}
                                    ${d.solve4 ? `Solve 4: ${d.solve4.toFixed(2)}s<br>` : ''}
                                    ${d.solve5 ? `Solve 5: ${d.solve5.toFixed(2)}s` : ''}
                                </div>
                            `)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", function () {
                            d3.select(this)
                                .transition()
                                .duration(200)
                                .attr("r", 4)
                                .style("stroke-width", "1.5px");

                            tooltip.transition()
                                .duration(500)
                                .style("opacity", 0);
                        });

                    chartContent.select(".brush").raise();
                }

                updateLegend(isSinglePlayerView, roundColorScale);
                updateStats(); // Add this line before the catch block

                // Add this to the updateChart function where the data is processed
                // Modify the line generation to group by round
                const linesByRound = d3.line()
                    .x(d => x(d.index))
                    .y(d => y(d.average))
                    .defined(d => !isNaN(d.average));

                // Create separate lines for each round
                state.activeRounds.forEach(round => {
                    const roundData = state.currentChartData.filter(d => d.round === round);

                    // Add round indicator to points
                    const points = chartContent.selectAll(`.point-${round}`)
                        .data(roundData);

                    points.enter()
                        .append("circle")
                        .attr("class", `point point-${round}`)
                        .merge(points)
                        .attr("cx", d => x(d.index))
                        .attr("cy", d => y(d.average))
                        .attr("r", 4)
                        .style("fill", d => colorScale(d.name))
                        .style("opacity", 0.8);

                    // Add round label to tooltip
                    chartContent.selectAll(`.point-${round}`)
                        .on("mouseover", function (event, d) {
                            // ... existing tooltip code ...
                            tooltip.html(`
                                <div class="tooltip-title">${d.name}</div>
                                <div class="tooltip-content">
                                    <strong>Round: ${d.round}</strong><br>
                                    Competition: ${d.competition}<br>
                                    Average: ${d.average.toFixed(2)}s
                                </div>
                            `);
                        });
                });

                updateSolvePatternLegend(state.isDetailedView);

            } catch (error) {
                console.error("Error updating chart:", error);
                displayError("Error updating chart");
            }
        }

        // Parse data function
        function parseData(csvText) {
            try {
                const rows = d3.csvParse(csvText);
                const competitors = {};
                const rounds = new Set();

                if (!rows.length) {
                    throw new Error("Empty CSV file");
                }

                rows.forEach(row => {
                    const name = row['Competitor Name'];
                    const round = row['Round'];

                    if (!name || !round) {
                        throw new Error("Missing required fields");
                    }

                    rounds.add(round);

                    if (!competitors[name]) {
                        competitors[name] = {};
                    }

                    if (!competitors[name][round]) {
                        competitors[name][round] = [];
                    }

                    competitors[name][round].push({
                        competition: row['Competition'],
                        round: round,
                        average: safeParseFloat(row['Average']),
                        solve1: safeParseFloat(row['Solve 1']),
                        solve2: safeParseFloat(row['Solve 2']),
                        solve3: safeParseFloat(row['Solve 3']),
                        solve4: safeParseFloat(row['Solve 4']),
                        solve5: safeParseFloat(row['Solve 5'])
                    });
                });

                // Sort and limit data
                Object.values(competitors).forEach(roundData => {
                    Object.values(roundData).forEach(competitorData => {
                        competitorData.sort((a, b) => a.competition.localeCompare(b.competition));
                        if (competitorData.length > 20) {
                            competitorData.splice(0, competitorData.length - 20);
                        }
                    });
                });

                return { competitors, rounds: Array.from(rounds) };

            } catch (error) {
                console.error("Error parsing data:", error);
                throw new Error("Error parsing CSV data");
            }
        }

        // Update toggles functions
        // Replace the existing updateRoundToggles function with this:

        // Update the updateRoundToggles function
        function updateRoundToggles() {
            const toggleContainer = d3.select("#round-toggles");
            toggleContainer.html("");

            state.allRounds.forEach(round => {
                const label = toggleContainer.append("label")
                    .attr("class", state.activeRounds.includes(round) ? "active" : "");

                label.append("input")
                    .attr("type", "radio")
                    .attr("name", "roundToggle")
                    .attr("checked", state.activeRounds.includes(round))
                    .on("change", function () {
                        toggleContainer.selectAll("label").classed("active", false);
                        label.classed("active", true);
                        state.activeRounds = [round];

                        // Reset zoom state when changing rounds
                        resetViewState();
                        updateChart();
                        updateStats();
                    });

                label.append("span").text(round);
            });
        }

        // Update the updatePlayerToggles function
        function updatePlayerToggles() {
            const toggleContainer = d3.select("#player-toggles");
            toggleContainer.html("");
            const showAllRoundsEnabled = state.showingAllRounds;

            Object.keys(state.competitors).forEach(name => {
                const label = toggleContainer.append("label")
                    .attr("class", state.activeCompetitors.includes(name) ? "active" : "")
                    .style("opacity", showAllRoundsEnabled && !state.activeCompetitors.includes(name) ? "0.5" : "1")
                    .style("cursor", showAllRoundsEnabled && !state.activeCompetitors.includes(name) ? "not-allowed" : "pointer");

                const input = label.append("input")
                    .attr("type", "checkbox")
                    .attr("checked", state.activeCompetitors.includes(name))
                    .property("disabled", showAllRoundsEnabled && !state.activeCompetitors.includes(name));

                input.on("change", function () {
                    if (showAllRoundsEnabled && state.activeCompetitors.length > 0 &&
                        !state.activeCompetitors.includes(name)) {
                        // Prevent selection if all rounds mode is active
                        this.checked = false;
                        return;
                    }

                    const isActive = d3.select(this).property("checked");
                    label.classed("active", isActive);

                    const index = state.activeCompetitors.indexOf(name);
                    if (isActive && index === -1) {
                        if (showAllRoundsEnabled) {
                            // Replace existing selection in all rounds mode
                            state.activeCompetitors = [name];
                            updatePlayerToggles();
                        } else {
                            // Add to selection in normal mode
                            state.activeCompetitors.push(name);
                        }
                    } else if (!isActive && index > -1) {
                        state.activeCompetitors.splice(index, 1);
                    }

                    if (showAllRoundsEnabled) {
                        // Update rounds when player changes in all rounds mode
                        const playerRounds = Object.keys(state.competitors[name]);
                        state.activeRounds = playerRounds;
                    }

                    resetViewState();
                    updateChart();
                    updateStats();
                });

                label.append("div")
                    .attr("class", "color-indicator")
                    .style("background-color", colorScale(name));

                label.append("span").text(name);
            });
        }

        // Update the updateStats function
        function updateStats() {
            // Update total competitors
            d3.select("#totalCompetitors")
                .text(Object.keys(state.competitors).length);

            // Update selected players
            d3.select("#selectedCount")
                .text(state.activeCompetitors.length);

            // Update active round
            d3.select("#activeRound")
                .text(state.activeRounds.join(", "));

            // Update view type
            d3.select("#viewType")
                .text(state.isDetailedView ? "Detailed View" : "Overview");

            // Calculate and update best time
            let bestTime = Infinity;
            state.currentChartData.forEach(d => {
                if (d.average && d.average < bestTime) {
                    bestTime = d.average;
                }
            });

            d3.select("#bestAverage")
                .text(bestTime === Infinity ? "-" : bestTime.toFixed(2) + "s");
        }

        // Event listeners
        document.getElementById('resetZoom').addEventListener('click', () => {
            try {
                state.zoomStack = [];
                state.currentZoomLevel = 0;
                state.isDetailedView = false;
                state.detailedViewData = null;

                svg.selectAll(".custom-x-labels").remove();
                chartContent.selectAll(".competition-label").remove();

                // Reset x-axis to show competition numbers
                const maxIndex = Math.max(...state.currentChartData.map(d => d.index));
                xAxis.transition()
                    .duration(750)
                    .call(d3.axisBottom(x)
                        .ticks(Math.min(20, maxIndex))
                        .tickFormat(d => Math.round(d)));
                        
                updateChart();
                updateZoomHistory();
                updateStats();
            } catch (error) {
                console.error("Error resetting zoom:", error);
                displayError("Error resetting view");
            }
        });

        // Replace the showAllRounds button event listener with this
        document.getElementById('showAllRoundsToggle').addEventListener('change', function () {
            try {
                const isChecked = this.checked;
                state.showingAllRounds = isChecked;

                if (isChecked) {
                    if (state.activeCompetitors.length === 0) {
                        // If no players selected, uncheck the toggle
                        this.checked = false;
                        state.showingAllRounds = false;
                        displayError("Please select a player first");
                        return;
                    }

                    // Keep only the first selected player if multiple are selected
                    if (state.activeCompetitors.length > 1) {
                        state.activeCompetitors = [state.activeCompetitors[0]];
                    }

                    // Enable all rounds for the selected player
                    const selectedPlayer = state.activeCompetitors[0];
                    const playerRounds = Object.keys(state.competitors[selectedPlayer]);
                    state.activeRounds = playerRounds;

                    // Update player toggles
                    updatePlayerToggles();

                    // Update round toggles
                    d3.selectAll('#round-toggles label').classed('active', function () {
                        const roundText = d3.select(this).text();
                        return playerRounds.includes(roundText);
                    });

                } else {
                    // Reset to final round
                    const finalRound = state.allRounds.find(round =>
                        round.toLowerCase().includes('final')
                    );
                    state.activeRounds = finalRound ? [finalRound] : [];

                    // Enable all player toggles
                    updatePlayerToggles();

                    // Update round toggles
                    d3.selectAll('#round-toggles label').classed('active', function () {
                        const roundText = d3.select(this).text();
                        return roundText === finalRound;
                    });
                }

                resetViewState();
                updateChart();
                updateStats();

            } catch (error) {
                console.error("Error toggling all rounds:", error);
                displayError("Error toggling rounds view");
            }
        });

        // Add this after state declaration
        document.addEventListener('DOMContentLoaded', function () {
            const filePath = './final.csv';
            showLoading();

            d3.csv(filePath)
                .then(rows => {
                    try {
                        const competitors = {};
                        const rounds = new Set();

                        // First, group data by competitor and round
                        rows.forEach(row => {
                            const name = row['Competitor Name'];
                            const round = row['Round'];

                            if (!name || !round) {
                                throw new Error("Missing required fields");
                            }

                            rounds.add(round);

                            if (!competitors[name]) {
                                competitors[name] = {};
                            }

                            if (!competitors[name][round]) {
                                competitors[name][round] = [];
                            }

                            competitors[name][round].push({
                                competition: row['Competition'],
                                round: round,
                                average: safeParseFloat(row['Average']),
                                solve1: safeParseFloat(row['Solve 1']),
                                solve2: safeParseFloat(row['Solve 2']),
                                solve3: safeParseFloat(row['Solve 3']),
                                solve4: safeParseFloat(row['Solve 4']),
                                solve5: safeParseFloat(row['Solve 5']),
                                date: new Date(row['Date'] || '2000-01-01') // Add date handling
                            });
                        });

                        // Sort and limit competitions for each competitor and round
                        Object.keys(competitors).forEach(name => {
                            Object.keys(competitors[name]).forEach(round => {
                                // Sort by date, most recent first
                                competitors[name][round].sort((a, b) => b.date - a.date);

                                // Keep only the 20 most recent competitions
                                if (competitors[name][round].length > 20) {
                                    competitors[name][round] = competitors[name][round].slice(0, 20);
                                }

                                // Add index for x-axis positioning
                                competitors[name][round].forEach((comp, index) => {
                                    comp.competitionIndex = index + 1;
                                });
                            });
                        });

                        // Find the final round
                        const finalRound = Array.from(rounds).find(round =>
                            round.toLowerCase().includes('final')
                        );

                        // Get top 5 competitors
                        const top5Competitors = getTop5Competitors(competitors, finalRound);

                        state = {
                            ...state,
                            competitors: competitors,
                            allRounds: Array.from(rounds),
                            activeCompetitors: top5Competitors, // Only top 5
                            activeRounds: finalRound ? [finalRound] : [], // Only final round
                            zoomStack: [],
                            currentZoomLevel: 0,
                            isDetailedView: false,
                            detailedViewData: null
                        };

                        updateRoundToggles();
                        updatePlayerToggles();
                        updateChart();
                        updateZoomHistory();
                        updateLegend();
                        updateStats();

                        // Update the toggle states visually
                        d3.selectAll('#round-toggles label').classed('active', function () {
                            const roundText = d3.select(this).text();
                            return roundText === finalRound;
                        });

                        d3.selectAll('#player-toggles label').classed('active', function () {
                            const playerText = d3.select(this).select('span').text();
                            return top5Competitors.includes(playerText);
                        });

                        // Update the checkboxes
                        d3.selectAll('#player-toggles input').property('checked', function () {
                            const playerText = d3.select(this.parentNode).select('span').text();
                            return top5Competitors.includes(playerText);
                        });

                    } catch (error) {
                        console.error("Error processing data:", error);
                        displayError("Error loading data");
                    } finally {
                        hideLoading();
                    }
                })
                .catch(error => {
                    console.error("Error loading file:", error);
                    displayError("Error loading data file");
                    hideLoading();
                });
        });

        // Add this function before the data loading:
        function getTop5Competitors(competitors, finalRound) {
            // Get all competitors' best averages in final round
            const bestAverages = Object.entries(competitors).map(([name, rounds]) => {
                const finalRoundData = rounds[finalRound] || [];
                const bestAverage = d3.min(finalRoundData, d => d.average) || Infinity;
                return { name, bestAverage };
            });

            // Sort by best average and get top 5
            return bestAverages
                .sort((a, b) => a.bestAverage - b.bestAverage)
                .slice(0, 5)
                .map(d => d.name);
        }

        // Add a helper function to reset view state
        function resetViewState() {
            state.zoomStack = [];
            state.currentZoomLevel = 0;
            state.isDetailedView = false;
            state.detailedViewData = null;
            updateZoomHistory();
        }

        // Add this function to create a color scale for rounds
        function getRoundColorScale(rounds) {
            // Use a different color scheme for rounds
            return d3.scaleOrdinal()
                .domain(rounds)
                .range(d3.schemeSet2); // Using a different color scheme than competitors
        }

        // Update the legend function to handle both modes
        function updateLegend(isSinglePlayerView, roundColorScale) {
            const legendContainer = d3.select("#legend");
            legendContainer.html("");

            if (isSinglePlayerView) {
                // Show round-based legend
                state.activeRounds.forEach(round => {
                    const legendItem = legendContainer.append("div")
                        .attr("class", "legend-item");

                    legendItem.append("div")
                        .attr("class", "legend-color")
                        .style("background-color", roundColorScale(round));

                    legendItem.append("span")
                        .text(`${round}`);
                });
            } else {
                // Show original competitor-based legend
                state.activeCompetitors.forEach(name => {
                    const legendItem = legendContainer.append("div")
                        .attr("class", "legend-item");

                    legendItem.append("div")
                        .attr("class", "legend-color")
                        .style("background-color", colorScale(name));

                    legendItem.append("span")
                        .text(name);
                });
            }
        }

        // Add this function to draw the solve pattern
        function updateSolvePatternLegend(isDetailedView) {
            const patternCard = d3.select(".solve-pattern-card");
            patternCard.classed("highlighted", isDetailedView);

            const svg = d3.select(".solve-pattern-legend svg");
            svg.selectAll("*").remove();

            if (!isDetailedView) return;

            const width = 200;
            const height = 100;
            const margin = { top: 20, right: 20, bottom: 20, left: 20 };

            const xScale = d3.scaleLinear()
                .domain([-0.4, 0.4])
                .range([margin.left, width - margin.right]);

            const yScale = d3.scaleLinear()
                .domain([0, 1])
                .range([height - margin.bottom, margin.top]);

            // Create zigzag pattern points
            const points = [
                { x: -0.4, y: 0.3 },  // S1
                { x: -0.2, y: 0.7 },  // S2
                { x: 0, y: 0.4 },     // S3
                { x: 0.2, y: 0.6 },   // S4
                { x: 0.4, y: 0.5 }    // S5
            ];

            // Add connecting line with zigzag pattern
            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y))
                .curve(d3.curveLinear); // Use linear curve for sharp zigzag

            // Update the stroke and fill colors to be more vibrant
            svg.append("path")
                .datum(points)
                .attr("class", "solve-line-example")
                .attr("d", line)
                .style("fill", "none")
                .style("stroke", "#3b82f6")
                .style("stroke-width", 2.5) // Increased stroke width
                .style("stroke-opacity", 0.8);

            // Make points more prominent
            svg.selectAll("circle")
                .data(points)
                .enter()
                .append("circle")
                .attr("cx", d => xScale(d.x))
                .attr("cy", d => yScale(d.y))
                .attr("r", 5) // Increased radius
                .style("fill", "#3b82f6")
                .style("stroke", "white")
                .style("stroke-width", 2)
                .style("filter", "drop-shadow(0 2px 2px rgba(59, 130, 246, 0.3))");

            // Make solve numbers more visible
            svg.selectAll(".solve-number")
                .data(points)
                .enter()
                .append("text")
                .attr("class", "solve-number")
                .attr("x", d => xScale(d.x))
                .attr("y", d => yScale(d.y) - 12)
                .attr("text-anchor", "middle")
                .style("font-size", "11px")
                .style("font-weight", "600")
                .style("fill", "#3b82f6")
                .text((d, i) => `S${i + 1}`);

            // Add subtle animation
            svg.selectAll("circle")
                .style("opacity", 0)
                .transition()
                .duration(400)
                .style("opacity", 1);

            svg.select(".solve-line-example")
                .style("opacity", 0)
                .transition()
                .duration(400)
                .style("opacity", 0.8);
        }
    </script>
</body>

</html>